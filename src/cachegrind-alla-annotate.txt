--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         3145728 B, 64 B, 12-way associative
Command:          main.exe
Data file:        cachegrind-alla.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
           Ir  I1mr  ILmr          Dr       D1mr       DLmr          Dw      D1mw      DLmw 
--------------------------------------------------------------------------------
2,120,913,049 1,620 1,610 993,270,357 25,922,938 20,697,362 263,904,410 3,708,461 3,664,415  PROGRAM TOTALS

--------------------------------------------------------------------------------
           Ir I1mr ILmr          Dr       D1mr      DLmr          Dw      D1mw      DLmw  file:function
--------------------------------------------------------------------------------
1,317,611,817   23   23 616,359,286  9,145,436 7,374,428 128,647,644 2,376,512 2,356,987  /xbar/nas2/home4/s06/s062397/thesis/src/qsufsort.c:sort_split
  136,473,425    7    7  89,926,082  4,074,249 3,123,731  22,213,796   375,018   375,017  /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.cpp:AlgorithmRmq1::logpreproc(int*, unsigned int*, unsigned int)
  128,996,994    7    7  66,999,547 11,234,805 8,814,735  16,999,879         1         1  /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.cpp:AlgorithmRmq1::query(unsigned int, unsigned int)
  126,000,069   11   11  64,000,012    437,380   411,441  16,000,035   500,008   500,008  /xbar/nas2/home4/s06/s062397/thesis/src/buildSa.cpp:TestString::buildSa()
   93,870,968    4    4  35,935,484          2         2  22,000,000         0         0  ???:random_r
   64,000,808    8    8  14,000,164    499,846   475,527  10,000,061   249,767   225,431  /xbar/nas2/home4/s06/s062397/thesis/src/qsufsort.c:suffixsort
   58,003,089   13   13  32,334,835    124,936   109,441   6,667,277    41,692    41,692  /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.cpp:AlgorithmRmq1::preproc(TestString*)
   52,000,000    2    2  16,000,000          1         0  12,000,000         0         0  ???:random
   51,313,456   11   11  22,131,390    258,220   258,213   8,131,355     8,213     8,212  /xbar/nas2/home4/s06/s062397/thesis/src/qsufsort.c:transform
   18,000,000    1    1   6,000,000          0         0   8,000,000         0         0  ???:rand
   14,998,132    2    2   3,999,940     15,072        40     999,985         0         0  /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.cpp:AlgorithmRmq1::log2fast(unsigned int)
   14,017,536  203  194  14,016,155        128        66         640         5         2  ???:???
   12,000,042    4    4   4,000,011          1         1   2,000,016    31,252    31,252  /xbar/nas2/home4/s06/s062397/thesis/src/str.cpp:TestString::TestString(unsigned int, string_type)
   11,000,085    5    5   5,000,030    125,026   125,010   4,000,030         2         2  /xbar/nas2/home4/s06/s062397/thesis/src/testRandom.cpp:testRandom(TestString*, unsigned int*, unsigned int, Algorithm*, bool, double)
   11,000,080    7    7           9          0         0   4,000,056   125,001   125,001  /xbar/nas2/home4/s06/s062397/thesis/src/cacheTest.cpp:cacheTest(unsigned int, string_type)
   10,000,000    1    1   2,000,000          0         0   2,000,000         0         0  /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.h:AlgorithmRmq1::query(unsigned int, unsigned int)

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/qsufsort.c
--------------------------------------------------------------------------------
         Ir I1mr ILmr          Dr      D1mr      DLmr         Dw      D1mw      DLmw 

-- line 31 ----------------------------------------
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Subroutine for select_sort_split and sort_split. Sets group numbers for a
          .    .    .           .         .         .          .         .         .     group whose lowest position in I is pl and highest position is pm.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  static void update_group(MY_INT *pl, MY_INT *pm)
          .    .    .           .         .         .          .         .         .  {
          .    .    .           .         .         .          .         .         .     MY_INT g;
          .    .    .           .         .         .          .         .         .  
  6,683,550    0    0   2,227,850         0         0  1,359,522         0         0     g=pm-I;                      /* group number.*/
  3,548,106    1    1   2,000,017        16         0  1,548,089    97,125    88,596     V[*pl]=g;                    /* update group number of first position.*/
  3,096,197    0    0           0         0         0          0         0         0     if (pl==pm)
  3,096,140    1    1   1,548,070         0         0  1,548,070         0         0        *pl=-1;                   /* one element, sorted group.*/
          .    .    .           .         .         .          .         .         .     else
          .    .    .           .         .         .          .         .         .        do                        /* more than one element, unsorted group.*/
107,708,556    0    0  35,902,852 2,243,929 2,243,929 35,902,852 2,243,930 2,243,930           V[*++pl]=g;            /* update group numbers.*/
 71,805,704    0    0           0         0         0          0         0         0        while (pl<pm);
          .    .    .           .         .         .          .         .         .  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Quadratic sorting method to use for small subarrays. To be able to update
          .    .    .           .         .         .          .         .         .     group numbers consistently, a variant of selection sorting is used.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  static void select_sort_split(MY_INT *p, MY_INT n) {
          .    .    .           .         .         .          .         .         .     MY_INT *pa, *pb, *pi, *pn;
          .    .    .           .         .         .          .         .         .     MY_INT f, v, tmp;
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .     pa=p;                        /* pa is start of group being picked out.*/
  1,355,787    0    0     451,929         0         0    451,929         0         0     pn=p+n-1;                    /* pn is last position of subarray.*/
  7,413,651    0    0   4,125,108         0         0    644,262         0         0     while (pa<pn) {
 18,845,787    2    2   9,506,291         2         2  1,548,060         0         0        for (pi=pb=pa+1, f=KEY(pa); pi<=pn; ++pi)
 12,153,162    1    1   6,076,581         0         0          0         0         0           if ((v=KEY(pi))<f) {
          .    .    .           .         .         .          .         .         .              f=v;                /* f is smallest key found.*/
        414    0    0         207         0         0        138         0         0              SWAP(pi, pa);       /* place smallest element at beginning.*/
          .    .    .           .         .         .          .         .         .              pb=pa+1;            /* pb is position for elements equal to f.*/
  4,050,916    0    0           0         0         0          0         0         0           } else if (v==f) {     /* if equal to smallest key.*/
          .    .    .           .         .         .          .         .         .              SWAP(pi, pb);       /* place next to other smallest elements.*/
          .    .    .           .         .         .          .         .         .              ++pb;
          .    .    .           .         .         .          .         .         .           }
  2,192,322    0    0   1,096,161         0         0          0         0         0        update_group(pa, pb-1);   /* update group values for new group.*/
          .    .    .           .         .         .          .         .         .        pa=pb;                    /* continue sorting rest of the subarray.*/
          .    .    .           .         .         .          .         .         .     }
  1,355,787    0    0     903,858         0         0          0         0         0     if (pa==pn) {                /* check if last part is single element.*/
  3,163,503    0    0   1,807,716         0         0    451,929    28,204    24,140        V[*pa]=pa-I;
    903,858    0    0     451,929         0         0    451,929         0         0        *pa=-1;                   /* sorted group.*/
          .    .    .           .         .         .          .         .         .     }
          .    .    .           .         .         .          .         .         .  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Subroutine for sort_split, algorithm by Bentley & McIlroy.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  static MY_INT choose_pivot(MY_INT *p, MY_INT n) {
          .    .    .           .         .         .          .         .         .     MY_INT *pl, *pm, *pn;
          .    .    .           .         .         .          .         .         .     MY_INT s;
          .    .    .           .         .         .          .         .         .     
  1,355,784    1    1           0         0         0          0         0         0     pm=p+(n>>1);                 /* small arrays, middle element.*/
  1,690,406    0    0           0         0         0    157,310         0         0     if (n>7) {
          .    .    .           .         .         .          .         .         .        pl=p;
  1,178,472    1    1           0         0         0    294,618         0         0        pn=p+n-1;
  1,178,472    0    0           0         0         0    294,618         0         0        if (n>40) {               /* big arrays, pseudomedian of 9.*/
          .    .    .           .         .         .          .         .         .           s=n>>3;
  1,677,399    3    3     872,257     5,408       134    268,423       789        33           pl=MED3(pl, pl+s, pl+s+s);
  1,475,721    1    1     871,999     7,927       158    134,148         0         0           pm=MED3(pm-s, pm, pm+s);
  1,408,842    2    2     737,864     7,573        91    134,148         0         0           pn=MED3(pn-s-s, pn-s, pn);
          .    .    .           .         .         .          .         .         .        }
  5,008,628    4    4   3,240,859         9         0          0         0         0        pm=MED3(pl, pm, pn);      /* midsize arrays, median of 3.*/
          .    .    .           .         .         .          .         .         .     }
  4,302,806    1    1   2,715,364       910        21  1,359,580         0         0     return KEY(pm);
          .    .    .           .         .         .          .         .         .  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Sorting routine called for each unsorted group. Sorts the array of integers
          .    .    .           .         .         .          .         .         .     (suffix numbers) of length n starting at p. The algorithm is a ternary-split
          .    .    .           .         .         .          .         .         .     quicksort taken from Bentley & McIlroy, "Engineering a Sort Function",
          .    .    .           .         .         .          .         .         .     Software -- Practice and Experience 23(11), 1249-1265 (November 1993). This
          .    .    .           .         .         .          .         .         .     function is based on Program 7.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  static void sort_split(MY_INT *p, MY_INT n)
  2,711,688    1    1           0         0         0  2,259,740     5,719       273  {
          .    .    .           .         .         .          .         .         .     MY_INT *pa, *pb, *pc, *pd, *pl, *pm, *pn;
          .    .    .           .         .         .          .         .         .     MY_INT f, v, s, t, tmp;
          .    .    .           .         .         .          .         .         .  
  3,383,769    1    1     224,066         0         0    224,066         0         0     if (n<7) {                   /* multi-selection sort smallest arrays.*/
          .    .    .           .         .         .          .         .         .        select_sort_split(p, n);
          .    .    .           .         .         .          .         .         .        return;
          .    .    .           .         .         .          .         .         .     }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .     v=choose_pivot(p, n);
          .    .    .           .         .         .          .         .         .     pa=pb=p;
          .    .    .           .         .         .          .         .         .     pc=pd=p+n-1;
          .    .    .           .         .         .          .         .         .     while (1) {                  /* split-end partition.*/
487,012,085    0    0 324,674,704 5,622,293 4,784,299          0         0         0        while (pb<=pc && (f=KEY(pb))<=v) {
 52,660,642    0    0           0         0         0          0         0         0           if (f==v) {
181,773,680    0    0  72,709,472    65,694    32,771 72,709,472         0         0              SWAP(pa, pb);
 36,354,736    0    0           0         0         0          0         0         0              ++pa;
          .    .    .           .         .         .          .         .         .           }
 52,660,642    0    0  52,660,642         0         0          0         0         0           ++pb;
          .    .    .           .         .         .          .         .         .        }
146,192,105    0    0  80,773,446 1,059,433   213,555          0         0         0        while (pc>=pb && (f=KEY(pc))>=v) {
 30,709,492    0    0           0         0         0          0         0         0           if (f==v) {
        176    0    0          88         7         1         88         0         0              SWAP(pc, pd);
        132    0    0           0         0         0         44         0         0              --pd;
          .    .    .           .         .         .          .         .         .           }
 15,354,746    0    0           0         0         0          0         0         0           --pc;
          .    .    .           .         .         .          .         .         .        }
          .    .    .           .         .         .          .         .         .        if (pb>pc)
          .    .    .           .         .         .          .         .         .           break;
  1,999,858    0    0           0         0         0  1,999,858         0         0        SWAP(pb, pc);
  2,999,787    0    0           0         0         0    999,929         0         0        ++pb;
    999,929    0    0           0         0         0          0         0         0        --pc;
          .    .    .           .         .         .          .         .         .     }
          .    .    .           .         .         .          .         .         .     pn=p+n;
  4,519,261    1    1     903,856         0         0          0         0         0     if ((s=pa-p)>(t=pb-pa))
          .    .    .           .         .         .          .         .         .        s=t;
  8,713,148    0    0     903,768         0         0          0         0         0     for (pl=p, pm=pb-s; s; --s, ++pl, ++pm)
  6,001,756    0    0   3,000,878   131,198    99,411  3,000,878         0         0        SWAP(pl, pm);
  4,519,280    1    1   1,355,784       166        10          0         0         0     if ((s=pd-pc)>(t=pn-pd-1))
          .    .    .           .         .         .          .         .         .        s=t;
    904,252    0    0          88         0         0          0         0         0     for (pl=pb, pm=pn-s; s; --s, ++pl, ++pm)
        176    0    0          88         9         0         88         0         0        SWAP(pl, pm);
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .     s=pb-pa;
          .    .    .           .         .         .          .         .         .     t=pd-pc;
    903,856    1    1           0         0         0          0         0         0     if (s>0)
  1,355,784    0    0     451,928         0         0    451,928       745        15        sort_split(p, s);
  3,615,424    0    0     903,856       646        23    451,928         0         0     update_group(p+s, p+n-t-1);
    903,856    0    0           0         0         0          0         0         0     if (t>0)
          .    .    .           .         .         .          .         .         .        sort_split(p+n-t, t);
  4,711,587    0    0   3,259,710       216        23          0         0         0  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Bucketsort for first iteration.
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .     Input: x[0...n-1] holds integers in the range 1...k-1, all of which appear
          .    .    .           .         .         .          .         .         .     at least once. x[n] is 0. (This is the corresponding output of transform.) k
          .    .    .           .         .         .          .         .         .     must be at most n+1. p is array of size n+1 whose contents are disregarded.
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .     Output: x is V and p is I after the initial sorting stage of the refined
          .    .    .           .         .         .          .         .         .     suffix sorting algorithm.*/
          .    .    .           .         .         .          .         .         .        
          .    .    .           .         .         .          .         .         .  static void bucketsort(MY_INT *x, MY_INT *p, MY_INT n, MY_INT k)
          .    .    .           .         .         .          .         .         .  {
          .    .    .           .         .         .          .         .         .     MY_INT *pi, i, c, d, g;
          .    .    .           .         .         .          .         .         .  
         13    1    1           0         0         0          0         0         0     for (pi=p; pi<p+k; ++pi)
          3    0    0           0         0         0          3         1         1        *pi=-1;                   /* mark linked lists empty.*/
  6,000,010    1    1           3         1         1          0         0         0     for (i=0; i<=n; ++i) {
 10,000,005    0    0   6,000,003   125,001   125,001  2,000,001         0         0        x[i]=p[c=x[i]];           /* insert in linked list.*/
  2,000,001    0    0           0         0         0  2,000,001         0         0        p[c]=i;
          .    .    .           .         .         .          .         .         .     }
         14    0    0           7         1         1          1         1         1     for (pi=p+k-1, i=n; pi>=p; --pi) {
         15    0    0          12         1         1          0         0         0        d=x[c=*pi];               /* c is position, d is next in list.*/
          3    0    0           0         0         0          3         0         0        x[c]=g=i;                 /* last position equals group number.*/
          6    0    0           0         0         0          0         0         0        if (d>=0) {               /* if more than one element in group.*/
          4    0    0           0         0         0          1         1         1           p[i--]=c;              /* p is permutation for the sorted x.*/
          .    .    .           .         .         .          .         .         .           do {
  5,999,994    1    1   3,999,996   124,745   100,427          0         0         0              d=x[c=d];           /* next in linked list.*/
  1,999,998    0    0           0         0         0  1,999,998         0         0              x[c]=g;             /* group number in x.*/
  5,999,994    0    0           0         0         0  1,999,998   125,000   125,000              p[i--]=c;           /* permutation in p.*/
  5,999,994    0    0           0         0         0          0         0         0           } while (d>=0);
          .    .    .           .         .         .          .         .         .        } else
          6    0    0           0         0         0          2         0         0           p[i--]=-1;             /* one element, sorted group.*/
          .    .    .           .         .         .          .         .         .     }
          .    .    .           .         .         .          .         .         .  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Transforms the alphabet of x by attempting to aggregate several symbols into
          .    .    .           .         .         .          .         .         .     one, while preserving the suffix order of x. The alphabet may also be
          .    .    .           .         .         .          .         .         .     compacted, so that x on output comprises all integers of the new alphabet
          .    .    .           .         .         .          .         .         .     with no skipped numbers.
          .    .    .           .         .         .          .         .         .  
-- line 195 ----------------------------------------
-- line 200 ----------------------------------------
          .    .    .           .         .         .          .         .         .     compaction is guaranteed; if k-l>n, compaction is never done; if q is
          .    .    .           .         .         .          .         .         .     INT_MAX, the maximum number of symbols are aggregated into one.
          .    .    .           .         .         .          .         .         .     
          .    .    .           .         .         .          .         .         .     Output: Returns an integer j in the range 1...q representing the size of the
          .    .    .           .         .         .          .         .         .     new alphabet. If j<=n+1, the alphabet is compacted. The global variable r is
          .    .    .           .         .         .          .         .         .     set to the number of old symbols grouped into one. Only x[n] is 0.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  static MY_INT transform(MY_INT *x, MY_INT *p, MY_INT n, MY_INT k, MY_INT l, MY_INT q)
          9    1    1           1         0         0          5         1         1  {
          .    .    .           .         .         .          .         .         .     MY_INT b, c, d, e, i, j, m, s;
          .    .    .           .         .         .          .         .         .     MY_INT *pi, *pj;
          .    .    .           .         .         .          .         .         .     
         28    1    1           4         0         0          3         0         0     for (s=0, i=k-l; i; i>>=1)
          9    0    0           9         0         0          0         0         0        ++s;                      /* s is number of bits in old symbol.*/
          .    .    .           .         .         .          .         .         .     e=MY_INT_MAX>>s;                /* e is for overflow checking.*/
         45    3    3          15         0         0          4         0         0     for (b=d=r=0; r<n && d<=e && (c=d<<s|(k-l))<=q; ++r) {
         14    0    0          10         1         1          2         0         0        b=b<<s|(x[r]-l+1);        /* b is start of x in chunk alphabet.*/
          .    .    .           .         .         .          .         .         .        d=c;                      /* d is max symbol in chunk alphabet.*/
          .    .    .           .         .         .          .         .         .     }
          4    1    1           1         0         0          0         0         0     m=(1<<(r-1)*s)-1;            /* m masks off top old symbol from chunk.*/
          5    0    0           2         0         0          1         0         0     x[n]=l-1;                    /* emulate zero terminator.*/
          2    0    0           1         0         0          0         0         0     if (d<=n) {                  /* if bucketing possible, compact alphabet.*/
    393,992    0    0           1         0         0          0         0         0        for (pi=p; pi<=p+d; ++pi)
    131,329    0    0           0         0         0    131,329     8,209     8,209           *pi=0;                 /* zero transformation table.*/
  6,000,011    1    1           6         2         0          3         0         0        for (pi=x+r, c=b; pi<=x+n; ++pi) {
  3,999,998    0    0   1,999,999         0         0  1,999,999         1         0           p[c]=1;                /* mark used chunk symbol.*/
 11,999,994    1    1   5,999,997   125,001   125,000  1,999,999         0         0           c=(c&m)<<s|(*pi-l+1);  /* shift in next old symbol in chunk.*/
          .    .    .           .         .         .          .         .         .        }
          8    0    0           4         1         1          0         0         0        for (i=1; i<r; ++i) {     /* handle last r-1 positions.*/
          1    0    0           0         0         0          1         1         1           p[c]=1;                /* mark used chunk symbol.*/
          3    0    0           0         0         0          1         0         0           c=(c&m)<<s;            /* shift in next old symbol in chunk.*/
          .    .    .           .         .         .          .         .         .        }
    393,992    1    1           0         0         0          1         0         0        for (pi=p, j=1; pi<=p+d; ++pi)
    393,987    0    0     131,329     8,209     8,208          0         0         0           if (*pi)
          8    0    0           2         1         1          4         0         0              *pi=j++;            /* j is new alphabet size.*/
  8,000,006    1    1           6         2         0          2         0         0        for (pi=x, pj=x+r, c=b; pj<=x+n; ++pi, ++pj) {
  5,999,997    0    0   3,999,998         1         0  1,999,999         1         1           *pi=p[c];              /* transform to new alphabet.*/
 13,999,993    0    0   9,999,995   125,000   125,000  1,999,999         0         0           c=(c&m)<<s|(*pj-l+1);  /* shift in next old symbol in chunk.*/
          .    .    .           .         .         .          .         .         .        }
          5    0    0           0         0         0          0         0         0        while (pi<x+n) {          /* handle last r-1 positions.*/
          4    1    1           2         1         1          1         0         0           *pi++=p[c];            /* transform to new alphabet.*/
          4    0    0           2         0         0          1         0         0           c=(c&m)<<s;            /* shift right-end zero in chunk.*/
          .    .    .           .         .         .          .         .         .        }
          .    .    .           .         .         .          .         .         .     } else {                     /* bucketing not possible, don't compact.*/
          .    .    .           .         .         .          .         .         .        for (pi=x, pj=x+r, c=b; pj<=x+n; ++pi, ++pj) {
          .    .    .           .         .         .          .         .         .           *pi=c;                 /* transform to new alphabet.*/
          .    .    .           .         .         .          .         .         .           c=(c&m)<<s|(*pj-l+1);  /* shift in next old symbol in chunk.*/
          .    .    .           .         .         .          .         .         .        }
          .    .    .           .         .         .          .         .         .        while (pi<x+n) {          /* handle last r-1 positions.*/
          .    .    .           .         .         .          .         .         .           *pi++=c;               /* transform to new alphabet.*/
          .    .    .           .         .         .          .         .         .           c=(c&m)<<s;            /* shift right-end zero in chunk.*/
          .    .    .           .         .         .          .         .         .        }
          .    .    .           .         .         .          .         .         .        j=d+1;                    /* new alphabet size.*/
          .    .    .           .         .         .          .         .         .     }
          1    0    0           0         0         0          1         0         0     x[n]=0;                      /* end-of-string symbol is zero.*/
          .    .    .           .         .         .          .         .         .     return j;                    /* return new alphabet size.*/
          7    0    0           6         1         1          0         0         0  }
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  /* Makes suffix array p of x. x becomes inverse of p. p and x are both of size
          .    .    .           .         .         .          .         .         .     n+1. Contents of x[0...n-1] are integers in the range l...k-1. Original
          .    .    .           .         .         .          .         .         .     contents of x[n] is disregarded, the n-th symbol being regarded as
          .    .    .           .         .         .          .         .         .     end-of-string smaller than all other symbols.*/
          .    .    .           .         .         .          .         .         .  
          .    .    .           .         .         .          .         .         .  void suffixsort(MY_INT *x, MY_INT *p, MY_INT n, MY_INT k, MY_INT l)
          8    2    2           3         0         0          4         0         0  {
          .    .    .           .         .         .          .         .         .     MY_INT *pi, *pk;
          .    .    .           .         .         .          .         .         .     MY_INT i, j, s, sl;
          .    .    .           .         .         .          .         .         .     
          2    0    0           1         0         0          1         1         1     V=x;                         /* set global values.*/
          1    0    0           0         0         0          1         0         0     I=p;
          .    .    .           .         .         .          .         .         .     
          4    0    0           1         0         0          0         0         0     if (n>=k-l) {                /* if bucketing possible,*/
          8    0    0           2         0         0          4         0         0        j=transform(V, I, n, k, l, n);
          .    .    .           .         .         .          .         .         .        bucketsort(V, I, n, j);   /* bucketsort on first r positions.*/
          .    .    .           .         .         .          .         .         .     } else {
          .    .    .           .         .         .          .         .         .        transform(V, I, n, k, l, MY_INT_MAX);
          .    .    .           .         .         .          .         .         .        for (i=0; i<=n; ++i)
          .    .    .           .         .         .          .         .         .           I[i]=i;                /* initialize I with suffix numbers.*/
          .    .    .           .         .         .          .         .         .        h=0;
          .    .    .           .         .         .          .         .         .        sort_split(I, n+1);       /* quicksort on first r positions.*/
          .    .    .           .         .         .          .         .         .     }
          2    0    0           1         1         1          1         0         0     h=r;                         /* number of symbols aggregated by transform.*/
          .    .    .           .         .         .          .         .         .     
        112    1    1          24        20        20          0         0         0     while (*I>=-n) {
          .    .    .           .         .         .          .         .         .        pi=I;                     /* pi is first position of group.*/
          .    .    .           .         .         .          .         .         .        sl=0;                     /* sl is negated length of sorted groups.*/
          .    .    .           .         .         .          .         .         .        do {
  6,000,123    0    0   2,000,041   125,017   125,017          0         0         0           if ((s=*pi)<0) {
  4,000,042    0    0           0         0         0          0         0         0              pi-=s;              /* skip over sorted group.*/
  2,000,021    0    0           0         0         0          0         0         0              sl+=s;              /* add negated length to sl.*/
          .    .    .           .         .         .          .         .         .           } else {
         40    0    0           0         0         0          0         0         0              if (sl) {
         20    0    0           0         0         0         20         7         0                 *(pi+sl)=sl;     /* combine sorted groups before pi.*/
          .    .    .           .         .         .          .         .         .                 sl=0;
          .    .    .           .         .         .          .         .         .              }
         60    0    0          40        36        35          0         0         0              pk=I+V[s]+1;        /* pk-1 is last position of unsorted group.*/
        140    0    0           0         0         0         20         7         0              sort_split(pi, pk-pi);
          .    .    .           .         .         .          .         .         .              pi=pk;              /* next group.*/
          .    .    .           .         .         .          .         .         .           }
  4,000,082    1    1           0         0         0          0         0         0        } while (pi<=I+n);
         42    0    0           0         0         0          0         0         0        if (sl)                   /* if the array ends with a sorted group.*/
          1    0    0           0         0         0          1         1         1           *(pi+sl)=sl;           /* combine sorted groups at end of I.*/
         21    0    0          21        20        20          0         0         0        h=2*h;                    /* double sorted-depth.*/
          .    .    .           .         .         .          .         .         .     }
          .    .    .           .         .         .          .         .         .  
  6,000,011    0    0           3         1         1          0         0         0     for (i=0; i<=n; ++i)         /* reconstruct suffix array from inverse.*/
  4,000,002    0    0   2,000,001   125,001   125,001  2,000,001   124,748   100,426        I[V[i]]=i;
          6    1    1           5         1         1          0         0         0  }  

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/buildSa.cpp
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr    D1mr    DLmr        Dw    D1mw    DLmw 

         .    .    .          .       .       .         .       .       .  #include <limits.h>
         .    .    .          .       .       .         .       .       .  #include "qsufsort.h"
         .    .    .          .       .       .         .       .       .  
         6    1    1          0       0       0         4       0       0  void TestString::buildSa() {
         8    0    0          2       0       0         3       0       0      MY_INT *my_sa = new (std::nothrow) MY_INT[n + 1];
         8    1    1          2       0       0         3       0       0      MY_INT *my_sainv = new (std::nothrow) MY_INT[n + 1];
         7    0    0          2       0       0         4       0       0      sa = new (std::nothrow) uint32[n];
         6    0    0          1       0       0         4       0       0      sainv = new (std::nothrow) uint32[n];
         7    1    1          1       0       0         5       0       0      lcp = new (std::nothrow) uint32[n];
        12    1    1          2       0       0         0       0       0      if (!(my_sa && my_sainv && sa && sainv && lcp)) {
         .    .    .          .       .       .         .       .       .          if (my_sa) delete[] my_sa;
         .    .    .          .       .       .         .       .       .          if (my_sainv) delete[] my_sainv;
         .    .    .          .       .       .         .       .       .          if (sa) delete[] sa;
         .    .    .          .       .       .         .       .       .          if (sainv) delete[] sainv;
         .    .    .          .       .       .         .       .       .          if (lcp) delete[] lcp;
         .    .    .          .       .       .         .       .       .          sa = NULL;
         .    .    .          .       .       .         .       .       .          sainv = NULL;
         .    .    .          .       .       .         .       .       .          lcp = NULL;
         2    0    0          1       0       0         0       0       0          return;
         .    .    .          .       .       .         .       .       .      }
         .    .    .          .       .       .         .       .       .  
         .    .    .          .       .       .         .       .       .      MY_INT k = UCHAR_MAX + 1;
         .    .    .          .       .       .         .       .       .      MY_INT l = 0;
         .    .    .          .       .       .         .       .       .  
 8,000,004    0    0  2,000,002       0       0         0       0       0      for (uint32 j = 0; j < n; j++)
 4,000,000    0    0  2,000,000  31,251  27,028 2,000,000 125,000 125,000          my_sainv[j] = s[j];
         6    1    1          0       0       0         6       2       2      suffixsort(my_sainv, my_sa, MY_INT(n), k, l); // qsufsort.h
         .    .    .          .       .       .         .       .       .  
         .    .    .          .       .       .         .       .       .      // transform from MY_INT to uint32
 8,000,008    0    0  4,000,004       2       2         1       1       1      for (uint32 i = 0; i < n; i++) {
 4,000,000    0    0  2,000,000 124,873 112,713 2,000,000 125,001 125,001          sa[i] = (uint32) my_sa[i + 1];
 4,000,000    0    0  2,000,000       0       0 2,000,000 125,001 125,001          sainv[(uint32) my_sa[i + 1]] = i;
         .    .    .          .       .       .         .       .       .      }
         4    0    0          0       0       0         2       2       2      delete[] my_sa;
         5    1    1          0       0       0         2       0       0      delete[] my_sainv;
         .    .    .          .       .       .         .       .       .  
         .    .    .          .       .       .         .       .       .      // from code_LiviuTinta/LCE/manzini_ds/lcp_aux.c
         .    .    .          .       .       .         .       .       .      // Compute the lcp array from the suffix array
         .    .    .          .       .       .         .       .       .      // using the algorithm by Kasai et al. (CPM '01)
         .    .    .          .       .       .         .       .       .  
         .    .    .          .       .       .         .       .       .      // rank = sa^{-1}
         .    .    .          .       .       .         .       .       .      // traverse suffixes in rank order
         .    .    .          .       .       .         .       .       .      uint32 h = 0;
12,000,013    1    1  8,000,005       0       0         5       0       0      for (uint32 i = 0; i < n; i++) {
 4,000,000    1    1  4,000,000 125,001 120,825         0       0       0          uint32 k = sainv[i];          // rank of s[i ... n-1]
 4,000,000    0    0          0       0       0         0       0       0          if (k > 0) {
15,999,992    0    0  7,999,996 125,000 119,620 3,999,998       0       0              uint32 j = sa[k-1];        // predecessor of s[i ... n-1]
41,999,981    2    2 17,999,993  31,251  31,251         0       0       0              while (i + h < n && j + h < n && s[i + h] == s[j + h])
 1,999,999    0    0          0       0       0 1,999,999       0       0                  h++;
13,999,993    0    0  9,999,995       2       2 3,999,998 125,001 125,001              lcp[k] = h;
         .    .    .          .       .       .         .       .       .          }
 4,000,000    0    0  4,000,000       0       0         0       0       0          if (h > 0) h--;
         .    .    .          .       .       .         .       .       .      }
         .    .    .          .       .       .         .       .       .  
         2    1    1          1       0       0         1       0       0      lcp[0] = 0;
         6    0    0          5       0       0         0       0       0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.h
--------------------------------------------------------------------------------
        Ir I1mr ILmr        Dr D1mr DLmr        Dw D1mw DLmw 

-- line 37 ----------------------------------------
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .      // block size
         .    .    .         .    .    .         .    .    .      uint32 bs;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .      // number of blocks (always n/bs)
         .    .    .         .    .    .         .    .    .      uint32 nb;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .      // return block of entry i:
10,000,000    1    1 2,000,000    0    0 2,000,000    0    0      inline uint32 block(uint32 i) { return i/bs; }
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .      // precomputed Catalan triangle (17 is enough for 64bit computing):
         .    .    .         .    .    .         .    .    .      static const uint32 Catalan[17][17];
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .      // minus infinity (change for 64bit version)
         .    .    .         .    .    .         .    .    .      static const int32 minus_infinity;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  
-- line 53 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/algRmq1.cpp
--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr      D1mr      DLmr         Dw    D1mw    DLmw 

          .    .    .          .         .         .          .       .       .  #include "algRmq1.h"
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  #include <stdio.h>
          .    .    .          .         .         .          .       .       .  #include <new>
          .    .    .          .         .         .          .       .       .  #include <math.h>
          .    .    .          .         .         .          .       .       .  
          4    1    1          1         0         0          2       0       0  AlgorithmRmq1::AlgorithmRmq1() {
          2    0    0          2         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  AlgorithmRmq1::~AlgorithmRmq1() {
          .    .    .          .         .         .          .       .       .  }
          .    .    .          .         .         .          .       .       .  
          4    1    1          2         0         0          1       0       0  void AlgorithmRmq1::getName(char* name, uint32 size) {
          4    0    0          0         0         0          3       0       0      snprintf(name, size, "RMQ<n;1>");
          1    0    0          1         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          7    2    2          1         0         0          4       0       0  uint64 AlgorithmRmq1::spaceUsage(uint32 n) {
         21    0    0          7         1         1          9       0       0      uint32 bs = (uint32) ceil(log2(n) / 4);
          5    1    1          1         0         0          0       0       0      uint32 nb = (n-1)/bs+1;
          .    .    .          .         .         .          .       .       .      uint32 qpb = bs * (bs+1) / 2;
          .    .    .          .         .         .          .       .       .      // log part
          5    0    0          2         0         0          3       0       0      uint32 depth = log2fast(nb);
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .      return sizeof(AlgorithmRmq1)
          .    .    .          .         .         .          .       .       .          + n*sizeof(uint32) // sainv
          .    .    .          .         .         .          .       .       .          + n*sizeof(uint32) // a
          .    .    .          .         .         .          .       .       .          + sizeof(uint32)*nb // c
          .    .    .          .         .         .          .       .       .          + sizeof(uint32)*nb // type
          .    .    .          .         .         .          .       .       .          + sizeof(uint32*)*Catalan[bs][bs] // Prec
          .    .    .          .         .         .          .       .       .          + sizeof(uint32)*qpb*Catalan[bs][bs] // Prec[i]
          .    .    .          .         .         .          .       .       .          // log part
          .    .    .          .         .         .          .       .       .          + sizeof(uint32*)*depth // logM
         19    0    0          2         1         1          0       0       0          + sizeof(uint32)*nb*depth; // logM[i]
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  /*
          .    .    .          .         .         .          .       .       .      bs = ceil(log2(n) / 4);
          .    .    .          .         .         .          .       .       .      nb = (n-1)/bs+1;
          .    .    .          .         .         .          .       .       .      words = 2*n + 2*nb + (bs * (bs+1) / 2 + 1)*Catalan_bs + (nb+1)*log2fast(nb);
          .    .    .          .         .         .          .       .       .  */
          6    0    0          5         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  const uint32 AlgorithmRmq1::Catalan[17][17] = {
          .    .    .          .         .         .          .       .       .      {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
          .    .    .          .         .         .          .       .       .      {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16},
          .    .    .          .         .         .          .       .       .      {0,0,2,5,9,14,20,27,35,44,54,65,77,90,104,119,135},
          .    .    .          .         .         .          .       .       .      {0,0,0,5,14,28,48,75,110,154,208,273,350,440,544,663,798},
          .    .    .          .         .         .          .       .       .      {0,0,0,0,14,42,90,165,275,429,637,910,1260,1700,2244,2907,3705},
          .    .    .          .         .         .          .       .       .      {0,0,0,0,0,42,132,297,572,1001,1638,2548,3808,5508,7752,10659,14364},
-- line 48 ----------------------------------------
-- line 56 ----------------------------------------
          .    .    .          .         .         .          .       .       .      {0,0,0,0,0,0,0,0,0,0,0,0,0,742900,2674440,7020405,15967980},
          .    .    .          .         .         .          .       .       .      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,2674440,9694845,25662825},
          .    .    .          .         .         .          .       .       .      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9694845,35357670},
          .    .    .          .         .         .          .       .       .      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35357670}
          .    .    .          .         .         .          .       .       .  };
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  const int32 AlgorithmRmq1::minus_infinity = -1;//-2147483648;
          .    .    .          .         .         .          .       .       .  
  8,000,000    1    1  2,000,000         0         0  4,000,000       0       0  uint32 AlgorithmRmq1::query(uint32 i, uint32 j) {
  2,000,000    0    0          0         0         0          0       0       0      if (i == j)
          .    .    .          .         .         .          .       .       .          return this->n - i;
          .    .    .          .         .         .          .       .       .  
  5,000,000    0    0  4,000,000   999,252   925,061  1,000,000       0       0      i = this->s->sainv[i];
  1,000,000    0    0  1,000,000   999,242   925,219          0       0       0      j = this->s->sainv[j];
          .    .    .          .         .         .          .       .       .  
  3,997,804    1    1          0         0         0          0       0       0      if (i > j) {
          .    .    .          .         .         .          .       .       .          uint32 m = i;
          .    .    .          .         .         .          .       .       .          i = j;
          .    .    .          .         .         .          .       .       .          j = m;
          .    .    .          .         .         .          .       .       .      }
          .    .    .          .         .         .          .       .       .  
  1,000,000    0    0          0         0         0          0       0       0      i++;
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .      uint32 block_i = block(i);       // block where i is
          .    .    .          .         .         .          .       .       .      uint32 block_j = block(j);       // j's block
  5,000,000    0    0  1,000,000         0         0  1,000,000       0       0      uint32 i_pos = i - (block_i*bs); // position of i in block_i
  4,000,000    0    0          0         0         0  2,000,000       0       0      uint32 j_pos = j - (block_j*bs); // pos. of j in block_j
          .    .    .          .         .         .          .       .       .      uint32 min, min_i, min_j; 		// min: to be returned
          .    .    .          .         .         .          .       .       .  
  3,000,072    0    0  2,000,040         4         3          0       0       0      if (block_j == block_i)
          .    .    .          .         .         .          .       .       .          min = (block_i*bs) + Prec[type[block_i]][i_pos*(bs-1)+j_pos-((i_pos-1)*i_pos/2)];
          .    .    .          .         .         .          .       .       .      else {
 17,999,928    1    1  9,999,960   996,642   624,418    999,996       0       0          min_i = (block_i*bs) + Prec[type[block_i]][(i_pos+1)*(bs-1)-((i_pos-1)*i_pos/2)];
  5,999,976    0    0  5,999,976   996,466   624,475          0       0       0          min_j = (block_j*bs) + Prec[type[block_j]][j_pos];
  7,999,968    0    0  3,999,984 1,997,576 1,762,690    999,996       0       0          min = a[min_i] < a[min_j] ? min_i : min_j;
  3,999,991    0    0  1,999,992         0         0          0       0       0          if (block_j > block_i + 1) { // out-of-block query:
          .    .    .          .         .         .          .       .       .              i = block_i+1;
  2,999,967    1    1    999,989         0         0    999,989       0       0              j = block_j-1;
          .    .    .          .         .         .          .       .       .  
  2,999,975    0    0          6         2         2          0       0       0              if (j-i == 0) min_i = c[j];
  2,999,985    0    0         24        10         7          0       0       0              else if (j-i == 1) min_i = c[logM[0][i]];
          .    .    .          .         .         .          .       .       .              else {
  5,999,898    1    1  2,999,949         0         0  2,999,949       1       1                  uint32 k = log2fast(j-i);
          .    .    .          .         .         .          .       .       .                  uint32 twotothek = 1 << k; // 2^k
 28,999,507    1    1 19,999,660 5,245,607 3,952,857  2,999,949       0       0                  min_i = c[loga[logc[logM[k-1][i]]] <= loga[logc[logM[k-1][j+1-twotothek]]] ? logM[k-1][i] : logM[k-1][j+1-twotothek]];
          .    .    .          .         .         .          .       .       .              }
  6,999,923    1    1  2,999,967         0         0          0       0       0              if (a[min_i] < a[min]) min = min_i;
          .    .    .          .         .         .          .       .       .          }
          .    .    .          .         .         .          .       .       .      }
          .    .    .          .         .         .          .       .       .  
  3,000,000    0    0  3,000,000         4         3          0       0       0      return s->lcp[min];
  6,000,000    0    0  5,000,000         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  /**
          .    .    .          .         .         .          .       .       .   * Standard Constructor. a is the array to be prepared for RMQ.
          .    .    .          .         .         .          .       .       .   * n is the size of the array.
          .    .    .          .         .         .          .       .       .   */
          7    1    1          1         0         0          4       0       0  bool AlgorithmRmq1::preproc(TestString* s) {
          2    0    0          1         0         0          1       0       0      this->s = s;
          2    1    1          1         0         0          1       0       0      int32* a = (int32*) s->lcp;
          2    0    0          1         0         0          1       0       0      uint32 n = s->n;
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          1    0    0          0         0         0          1       0       0      this->a = a;
          1    0    0          0         0         0          1       0       0      this->n = n;
         23    1    1          8         0         0         10       0       0      bs = (uint32) ceil(log2(n) / 4); // calculate block size
          6    0    0          1         0         0          1       0       0      nb = block(n-1)+1;              // number of blocks
          4    0    0          0         0         0          1       0       0      qpb = bs * (bs+1) / 2;          // # of different queries per block
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .      // allocate and fill arrays for out-of-block-queries;
          .    .    .          .         .         .          .       .       .      // combined with type-calculation for the blocks:
          4    1    1          0         0         0          3       0       0      c = new uint32[nb];
          5    0    0          1         0         0          3       0       0      type = new uint32[nb];
          7    0    0          2         0         0          3       0       0      Prec = new uint32*[Catalan[bs][bs]];
        798    2    2        266         0         0          0       0       0      for (uint32 i = 0; i < Catalan[bs][bs]; i++) {
      1,056    0    0        396         0         0        396       8       8          Prec[i] = new uint32[qpb];
        660    0    0        528         0         0        132      17      17          Prec[i][0] = bs; // init with impossible value
          .    .    .          .         .         .          .       .       .      }
          4    0    0          0         0         0          3       0       0      int32* rp = new int32[bs+1];  // rp: rightmost path in Cart. tree
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .      uint32 min;   // position of minimum in current block
          .    .    .          .         .         .          .       .       .      uint32 z=0;   // index in array a
          .    .    .          .         .         .          .       .       .      uint32 end;   // end of current block
          .    .    .          .         .         .          .       .       .      uint32 start; // start of current block
          .    .    .          .         .         .          .       .       .      uint32 q;     // position in Catalan triangle
          .    .    .          .         .         .          .       .       .      uint32 p;     // --------- " ----------------
          1    0    0          0         0         0          1       0       0      rp[0] = minus_infinity; // stopper (minus infinity)
          .    .    .          .         .         .          .       .       .  
  3,000,020    1    1  1,666,675         0         0    333,340       0       0      for (uint32 i = 0; i < nb; i++) { // step through blocks
          .    .    .          .         .         .          .       .       .          start = z;            // init start
          .    .    .          .         .         .          .       .       .          min = start;          // init minimum
  3,333,341    1    1  1,333,336         0         0    666,669       0       0          end = start + bs;     // end of block
          .    .    .          .         .         .          .       .       .          if (end > n) end = n; // last block could be smaller than bs!
          .    .    .          .         .         .          .       .       .          q = bs;       // init q
  3,333,340    1    1    333,334         0         0    666,668       0       0          p = bs-1;     // init p
    666,668    0    0    333,334         0         0    333,334  20,833  20,833          type[i] = 0;  // init type (will be increased!)
  2,333,338    0    0  1,666,670    41,643    36,481    333,334       0       0          rp[1] = a[z]; // init rightmost path
          .    .    .          .         .         .          .       .       .  
 16,333,330    1    1 11,999,996         0         0    666,668       0       0          while (++z < end) {   // step through current block:
  8,333,330    0    0  6,666,664    83,291    72,958          0       0       0              if (a[z] < a[min]) min = z;   // update minimum
  3,333,332    0    0          0         0         0  1,666,666       0       0              p--;
  9,999,996    0    0  3,333,332         0         0          0       0       0              while (rp[q-p-1] > a[z]) {
          .    .    .          .         .         .          .       .       .                  type[i] += Catalan[p][q]; // update type
          .    .    .          .         .         .          .       .       .                  q--;
          .    .    .          .         .         .          .       .       .              }
  3,333,332    0    0  1,666,666         0         0  1,666,666       0       0              rp[q-p] = a[z]; // add last element to rightmost path
          .    .    .          .         .         .          .       .       .          }
  1,333,336    0    0  1,000,002         0         0    333,334  20,833  20,833          c[i] = min; // store index of minimum
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .          // precompute in-block-queries for this block (if necessary):
  2,666,672    1    1  2,333,338         0         0          0       0       0          if (Prec[type[i]][0] == bs) {
          .    .    .          .         .         .          .       .       .              p = 0; // now index in Prec[type[i]]
         26    1    1          7         0         0          6       0       0              for (uint32 j = start; j < end; j++) {
          .    .    .          .         .         .          .       .       .                  min = j;
         90    0    0         48         0         0          0       0       0                  for (uint32 k = j; k < end; k++) {
         84    0    0         63         0         0          0       0       0                      if (a[k] < a[min]) min = k;
        231    0    0        147         0         0         21       0       0                      Prec[type[i]][p++] = min-start;
          .    .    .          .         .         .          .       .       .                  }
          .    .    .          .         .         .          .       .       .              }
          .    .    .          .         .         .          .       .       .          }
          .    .    .          .         .         .          .       .       .      }
          3    0    0          1         0         0          2       1       1      delete[] rp;
          .    .    .          .         .         .          .       .       .  
         30    1    1         11         0         0          7       0       0      logpreproc(a, c, nb); // construct sparse table on block-minima
          .    .    .          .         .         .          .       .       .      return true; // TODO check OOM
          7    0    0          5         2         2          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  /**
          .    .    .          .         .         .          .       .       .   * Destructor. Deletes allocated space.
          .    .    .          .         .         .          .       .       .   */
          6    0    0          1         0         0          3       0       0  void AlgorithmRmq1::cleanup() {
          .    .    .          .         .         .          .       .       .      logcleanup();
          5    0    0          1         0         0          2       0       0      delete[] type;
          5    1    1          1         0         0          2       0       0      delete[] c;
        536    1    1        135         1         1          0       0       0      for (uint32 i = 0; i < Catalan[bs][bs]; i++)
        924    0    0        396         8         8        264       0       0          delete[] Prec[i];
          4    0    0          0         0         0          1       0       0      delete[] Prec;
          4    0    0          3         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  const char AlgorithmRmq1::LogTable256[256] = 
          .    .    .          .         .         .          .       .       .  	{
          .    .    .          .         .         .          .       .       .  		0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
-- line 202 ----------------------------------------
-- line 212 ----------------------------------------
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
          .    .    .          .         .         .          .       .       .  		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
          .    .    .          .         .         .          .       .       .  	};
          .    .    .          .         .         .          .       .       .  
  2,999,955    1    1    999,985         0         0    999,985       0       0  uint32 AlgorithmRmq1::log2fast(uint32 v) {
          .    .    .          .         .         .          .       .       .  	uint32 c = 0;          // c will be lg(v)
          .    .    .          .         .         .          .       .       .  	register uint32 t, tt; // temporaries
          .    .    .          .         .         .          .       .       .  
  3,999,940    0    0          0         0         0          0       0       0  	if (tt = v >> 16)
  3,870,246    0    0    645,041        36        31          0       0       0  		c = (t = v >> 24) ? 24 + LogTable256[t] : 16 + LogTable256[tt & 0xFF];
          .    .    .          .         .         .          .       .       .  	else 
  2,128,021    1    1    354,944    15,036         9          0       0       0  		c = (t = v >> 8) ? 8 + LogTable256[t] : LogTable256[v];
          .    .    .          .         .         .          .       .       .  	return c;
  1,999,970    0    0  1,999,970         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  /**
          .    .    .          .         .         .          .       .       .   * Standard Constructor. a[c[0]],...,a[c[n-1]] is the array to be prepared for RMQ.
          .    .    .          .         .         .          .       .       .   * n is the size of the index array c.
          .    .    .          .         .         .          .       .       .   */
          7    1    1          1         0         0          4       0       0  void AlgorithmRmq1::logpreproc(int32* a, uint32* c, uint32 n) {
          .    .    .          .         .         .          .       .       .  
          2    0    0          1         0         0          1       0       0  	this->loga = a;
          2    0    0          1         0         0          1       0       0  	this->logc = c;
          2    0    0          1         0         0          1       0       0  	this->logn = n;
          5    1    1          2         1         1          4       0       0  	uint32 depth = log2fast(n); // table depth
          1    0    0          0         0         0          1       0       0  	logdepth = depth;
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  	// allocate space for table:
          4    0    0          0         0         0          3       0       0  	uint32** M = new uint32*[depth];
          1    0    0          0         0         0          1       0       0      logM = M;
         60    1    1         20         0         0          0       0       0  	for (uint32 i = 0; i < depth; i++)
         72    0    0         18         0         0         54       0       0  		M[i] = new uint32[n];
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  	// fill table:
    666,677    0    0    333,337         0         0          2       0       0  	for (uint32 i = 0; i < n-1; i++) // fill first row
  3,999,996    1    1  2,333,331   145,835   145,835    333,333  20,834  20,833  		M[0][i] = a[c[i]] <= a[c[i+1]] ? i : i+1;
          8    0    0          5         1         1          1       0       0  	if (depth > 0) M[0][n-1] = n-1;          // fill overhang in first row
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  	uint32 dist = 1; // always 2^j
         72    1    1         52         0         0          2       0       0  	for (uint32 j = 1; j < depth; j++) {
         17    0    0         17         0         0          0       0       0  		dist *= 2;
 27,022,918    2    2 16,213,744        11         6         68       0       0  		for (uint32 i = 0; i < n - dist; i++) // fill jth row
102,686,184    0    0 70,258,968 3,912,094 2,970,103 21,618,144 337,800 337,800  			M[j][i] = a[c[M[j-1][i]]] <= a[c[M[j-1][i+dist]]] ? M[j-1][i] : M[j-1][i+dist];
  2,097,391    0    0    786,579    16,307     7,785    262,176  16,384  16,384  		for (uint32 i = n - dist; i < n; i++) M[j][i] = M[j-1][i]; // overhang
          .    .    .          .         .         .          .       .       .  	}
          6    0    0          5         0         0          0       0       0  }
          .    .    .          .         .         .          .       .       .  
          .    .    .          .         .         .          .       .       .  /**
          .    .    .          .         .         .          .       .       .   * Destructor. Deletes allocated space.
          .    .    .          .         .         .          .       .       .   */
          .    .    .          .         .         .          .       .       .  void AlgorithmRmq1::logcleanup() {
         61    0    0         20         0         0          0       0       0  	for (uint32 i = 0; i < logdepth; i++)
        108    1    1         36         1         0         36       0       0  		delete[] logM[i];
          4    0    0          0         0         0          2       0       0  	delete[] logM;
          .    .    .          .         .         .          .       .       .  }
          .    .    .          .         .         .          .       .       .  

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/str.cpp
--------------------------------------------------------------------------------
        Ir I1mr ILmr        Dr D1mr DLmr        Dw   D1mw   DLmw 

-- line 11 ----------------------------------------
         .    .    .         .    .    .         .      .      .      if (sa)
         .    .    .         .    .    .         .      .      .          delete[] sa;
         .    .    .         .    .    .         .      .      .      if (sa)
         .    .    .         .    .    .         .      .      .          delete[] sainv;
         .    .    .         .    .    .         .      .      .      if (lcp)
         .    .    .         .    .    .         .      .      .          delete[] lcp;
         .    .    .         .    .    .         .      .      .  }
         .    .    .         .    .    .         .      .      .  
         3    1    1         1    0    0         1      0      0  const char* nameStr(enum string_type type) {
         4    0    0         1    1    1         0      0      0      switch (type) {
         .    .    .         .    .    .         .      .      .      case RANDOM4_STRING:
         .    .    .         .    .    .         .      .      .          return "Random-4";
         .    .    .         .    .    .         .      .      .      case RANDOM10_STRING:
         .    .    .         .    .    .         .      .      .          return "Random-10";
         .    .    .         .    .    .         .      .      .      case RANDOM255_STRING:
         2    0    0         0    0    0         0      0      0          return "Random-255";
         .    .    .         .    .    .         .      .      .      case ALL_A_STRING:
         .    .    .         .    .    .         .      .      .          return "All a";
         .    .    .         .    .    .         .      .      .      case RANDOM10_REPEAT10_STRING:
         .    .    .         .    .    .         .      .      .          return "Random-10-Repeat-10";
         .    .    .         .    .    .         .      .      .      default:
         .    .    .         .    .    .         .      .      .          return "UNKNOWN";
         .    .    .         .    .    .         .      .      .      }
         2    0    0         2    0    0         0      0      0  }
         .    .    .         .    .    .         .      .      .  
         .    .    .         .    .    .         .      .      .  /**
         .    .    .         .    .    .         .      .      .   * Initializes a pre-allocated buffer s->s of size n+1 with a string of
         .    .    .         .    .    .         .      .      .   * length s->n with characters from the alphabet [1..mod], where each character
         .    .    .         .    .    .         .      .      .   * is chosen uniformly at random.
         .    .    .         .    .    .         .      .      .   */
         .    .    .         .    .    .         .      .      .  void strRandom(TestString* s, uint8 mod, bool print) {
         .    .    .         .    .    .         .      .      .      uint32 i;
-- line 42 ----------------------------------------
-- line 47 ----------------------------------------
         .    .    .         .    .    .         .      .      .      }
         .    .    .         .    .    .         .      .      .      s->s[s->n] = 0;
         .    .    .         .    .    .         .      .      .      if (print) std::cout << ", n=" << s->n << "\n";
         .    .    .         .    .    .         .      .      .      snprintf(s->name, 20, "random n=%i c=%i", s->n, mod);
         .    .    .         .    .    .         .      .      .  }
         .    .    .         .    .    .         .      .      .  
         .    .    .         .    .    .         .      .      .  void strAllA(TestString* s) {
         .    .    .         .    .    .         .      .      .      uint32 i;
12,000,004    1    1 4,000,001    0    0 2,000,000 31,250 31,250      for (i = 0; i < s->n; i++) s->s[i] = 'a';
         2    1    1         1    0    0         1      0      0      s->s[s->n] = 0;
         8    0    0         1    0    0         5      1      1      snprintf(s->name, 20, "all a n=%i", s->n);
         .    .    .         .    .    .         .      .      .  }
         .    .    .         .    .    .         .      .      .  
         9    1    1         3    0    0         4      0      0  TestString::TestString(uint32 n, enum string_type type) {
         1    0    0         0    0    0         1      0      0      this->n = n;
         5    0    0         0    0    0         4      0      0      this->s = new (std::nothrow) uint8[n+1];
         2    0    0         0    0    0         0      0      0      if (!this->s)
         .    .    .         .    .    .         .      .      .          return;
         3    1    1         1    1    1         0      0      0      switch (type) {
         .    .    .         .    .    .         .      .      .      case RANDOM4_STRING:
         .    .    .         .    .    .         .      .      .          strRandom(this, 4, false);
         .    .    .         .    .    .         .      .      .          break;
         .    .    .         .    .    .         .      .      .      case RANDOM10_STRING:
         .    .    .         .    .    .         .      .      .          strRandom(this, 10, false);
         .    .    .         .    .    .         .      .      .          break;
         .    .    .         .    .    .         .      .      .      case RANDOM255_STRING:
         .    .    .         .    .    .         .      .      .          strRandom(this, 255, false);
         1    0    0         0    0    0         0      0      0          break;
         .    .    .         .    .    .         .      .      .      case ALL_A_STRING:
         .    .    .         .    .    .         .      .      .          strAllA(this);
         .    .    .         .    .    .         .      .      .          break;
         .    .    .         .    .    .         .      .      .      case RANDOM10_REPEAT10_STRING:
         .    .    .         .    .    .         .      .      .          this->n = n/10;
         .    .    .         .    .    .         .      .      .          strRandom(this, 10, false);
         .    .    .         .    .    .         .      .      .          for (uint32 i = 0; i < n; i++)
         .    .    .         .    .    .         .      .      .              this->s[i] = this->s[i % this->n];
         .    .    .         .    .    .         .      .      .          this->s[n] = 0;
         .    .    .         .    .    .         .      .      .          this->n = n;
         .    .    .         .    .    .         .      .      .          break;
         .    .    .         .    .    .         .      .      .      }
         2    0    0         0    0    0         1      1      1      buildSa();
         5    0    0         4    0    0         0      0      0  }
         .    .    .         .    .    .         .      .      .  
         .    .    .         .    .    .         .      .      .  TestString::TestString(const char* fileName) {
         .    .    .         .    .    .         .      .      .      FILE* file = fopen(fileName, "rb");
         .    .    .         .    .    .         .      .      .      if (!file) {
         .    .    .         .    .    .         .      .      .          std::cout << "There is an error opening the file.\n";
         .    .    .         .    .    .         .      .      .          // if( errno == EOVERFLOW ) std::cout << "TRUE" << "\n";
         .    .    .         .    .    .         .      .      .          return;
         .    .    .         .    .    .         .      .      .      }
-- line 96 ----------------------------------------
-- line 110 ----------------------------------------
         .    .    .         .    .    .         .      .      .      s[n] = 0;
         .    .    .         .    .    .         .      .      .      //cout << "Errno: " << errno << endl;
         .    .    .         .    .    .         .      .      .  
         .    .    .         .    .    .         .      .      .      fclose(file);
         .    .    .         .    .    .         .      .      .  
         .    .    .         .    .    .         .      .      .      buildSa();
         .    .    .         .    .    .         .      .      .  }
         .    .    .         .    .    .         .      .      .  
         5    1    1         1    0    0         2      0      0  bool checkStr(TestString* s) {
         3    0    0         0    0    0         0      0      0      if (!s)
         .    .    .         .    .    .         .      .      .          return false;
         4    0    0         1    0    0         0      0      0      if (!s->lcp) {
         .    .    .         .    .    .         .      .      .          delete s;
         .    .    .         .    .    .         .      .      .          return false;
         .    .    .         .    .    .         .      .      .      }
         .    .    .         .    .    .         .      .      .      return true;
        13    1    1         5    0    0         1      0      0  }
         6    1    1         1    0    0         1      0      0  <bogus line 127>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@
@@ Information recorded about lines past the end of '/xbar/nas2/home4/s06/s062397/thesis/src/str.cpp'.
@@
@@ Probable cause and solution:
@@ cause:    not sure, sorry
@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/cacheTest.cpp
--------------------------------------------------------------------------------
       Ir I1mr ILmr Dr D1mr DLmr        Dw    D1mw    DLmw 

        .    .    .  .    .    .         .       .       .  #include "cacheTest.h"
        .    .    .  .    .    .         .       .       .  #include "algorithm.h"
        .    .    .  .    .    .         .       .       .  #include "algRmq1.h"
        .    .    .  .    .    .         .       .       .  #include "testRandom.h"
        .    .    .  .    .    .         .       .       .  #include <iostream>
        .    .    .  .    .    .         .       .       .  
        9    1    1  2    0    0         5       0       0  void cacheTest(uint32 n, enum string_type type) {
       18    1    1  0    0    0        17       0       0      std::cout << "Cachegrind test for string " << nameStr(type) << " length " << n << "\n";
        5    0    0  0    0    0         5       0       0      Algorithm* rmq1 = new AlgorithmRmq1;
        .    .    .  .    .    .         .       .       .  
        .    .    .  .    .    .         .       .       .      uint32 paircount = 1000000;
        5    1    1  0    0    0         3       0       0      uint32* pairs = new (std::nothrow) uint32[paircount*2];
        3    0    0  0    0    0         0       0       0      if (!pairs) {
        .    .    .  .    .    .         .       .       .          delete rmq1;
        .    .    .  .    .    .         .       .       .          std::cout << "Cannot allocate pairs\n";
        .    .    .  .    .    .         .       .       .          return;
        .    .    .  .    .    .         .       .       .      }
        .    .    .  .    .    .         .       .       .  
3,000,000    0    0  0    0    0         0       0       0      for (uint32 i = 0; i < paircount*2; i += 2) {
4,000,000    0    0  0    0    0 2,000,000 125,000 125,000          pairs[i] = rand() % n;
4,000,000    0    0  0    0    0 2,000,000       0       0          pairs[i + 1] = rand() % n;
        .    .    .  .    .    .         .       .       .      }
        .    .    .  .    .    .         .       .       .  
       11    1    1  1    0    0         7       0       0      TestString* s = new (std::nothrow) TestString(n, type);
        4    0    0  0    0    0         2       0       0      if (!checkStr(s)) {
        .    .    .  .    .    .         .       .       .          delete rmq1;
        .    .    .  .    .    .         .       .       .          delete pairs;
        1    0    0  0    0    0         0       0       0          std::cout << "Cannot allocate string\n";
        .    .    .  .    .    .         .       .       .          return;
        .    .    .  .    .    .         .       .       .      }
        .    .    .  .    .    .         .       .       .      
       10    2    2  1    0    0         9       1       1      double time = testRandom(s, pairs, paircount, rmq1, false, 10000);
        9    0    0  1    0    0         8       0       0      std::cout << "Time was " << time << ".\n";
       14    2    2  6    0    0         1       0       0  }
        6    1    1  1    0    0         1       0       0  <bogus line 35>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@
@@ Information recorded about lines past the end of '/xbar/nas2/home4/s06/s062397/thesis/src/cacheTest.cpp'.
@@
@@ Probable cause and solution:
@@ cause:    not sure, sorry
@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

--------------------------------------------------------------------------------
-- Auto-annotated source: /xbar/nas2/home4/s06/s062397/thesis/src/testRandom.cpp
--------------------------------------------------------------------------------
       Ir I1mr ILmr        Dr    D1mr    DLmr        Dw D1mw DLmw 

        .    .    .         .       .       .         .    .    .  #include "testRandom.h"
        .    .    .         .       .       .         .    .    .  #include <stdlib.h>
        .    .    .         .       .       .         .    .    .  #include <stdio.h>
        .    .    .         .       .       .         .    .    .  #include "timer.h"
        .    .    .         .       .       .         .    .    .  
        .    .    .         .       .       .         .    .    .  /**
        .    .    .         .       .       .         .    .    .   * Tests a given agorithm on a given string using random query pairs.
        .    .    .         .       .       .         .    .    .   */
       11    1    1         3       0       0         6    1    1  double testRandom(TestString* s, uint32* pairs, uint32 paircount, Algorithm* a, bool print, double preproc_time_limit) {
        .    .    .         .       .       .         .    .    .      uint32 x;
        .    .    .         .       .       .         .    .    .      double start;
        .    .    .         .       .       .         .    .    .      double end;
        .    .    .         .       .       .         .    .    .      char algName[ALGORITHM_NAME_SIZE];
        6    0    0         2       2       2         4    1    1      a->getName(algName, ALGORITHM_NAME_SIZE);
       20    1    1         7       1       1         6    0    0      if (a->spaceUsage(s->n) > 1e9) {
        .    .    .         .       .       .         .    .    .          if (print) printf("\ntestRandom,%s,too much memory,%s\n", algName, s->name);
        .    .    .         .       .       .         .    .    .          return -1;
        .    .    .         .       .       .         .    .    .      }
        2    1    1         0       0       0         2    0    0      start = gettime();
        6    0    0         3       0       0         3    0    0      bool success = a->preproc(s);
        1    0    0         0       0       0         1    0    0      end = gettime();
        2    0    0         0       0       0         0    0    0      if (!success) {
        .    .    .         .       .       .         .    .    .          if (print) printf("\ntestRandom,%s,out of memory,%s\n", algName, s->name);
        .    .    .         .       .       .         .    .    .          return -1;
        .    .    .         .       .       .         .    .    .      }
        7    0    0         2       1       1         0    0    0      if (end - start > preproc_time_limit) {
        .    .    .         .       .       .         .    .    .          a->cleanup();
        .    .    .         .       .       .         .    .    .          if (print) printf("\ntestRandom,%s,preprocessing timed out,%s\n", algName, s->name);
        .    .    .         .       .       .         .    .    .          return -1;
        .    .    .         .       .       .         .    .    .      }
        2    1    1         0       0       0         2    0    0      start = gettime();
3,000,005    0    0         1       1       1         0    0    0      for (x = 0; x < paircount*2; x += 2) {
        .    .    .         .       .       .         .    .    .          uint32 i = pairs[x];
        .    .    .         .       .       .         .    .    .          uint32 j = pairs[x + 1];
8,000,000    0    0 5,000,000 125,019 125,003 4,000,000    0    0          uint32 lce = a->query(i, j);
        .    .    .         .       .       .         .    .    .          //printf("i=%i, j=%i, lce=%i\n", i, j, lce);
        .    .    .         .       .       .         .    .    .      }
        1    0    0         0       0       0         1    0    0      end = gettime();
       11    1    1         4       1       1         2    0    0      if (print) printf("\ntestRandom,%s,%e,%s\n", algName, (end - start) / (double) paircount, s->name);
        5    0    0         3       0       0         3    0    0      a->cleanup();
        .    .    .         .       .       .         .    .    .      return (end - start) / (double) paircount;
        6    0    0         5       1       1         0    0    0  }

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
92    7    7 93  100  100 84  100  100  percentage of events annotated

